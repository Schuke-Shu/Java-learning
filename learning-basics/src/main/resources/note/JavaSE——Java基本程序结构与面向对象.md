> 相关网址

| 网址                                                       | 说明                                                 |
| ---------------------------------------------------------- | ---------------------------------------------------- |
| https://www.oracle.com                                     | Oracle官网（Java目前属于Oracle公司）                 |
| https://www.oracle.com/cn/java                             | Java中文官网                                         |
| www.oracle.com/technetwork/java/javase/downloads           | Java开发工具包与文档下载地址                         |
| http://openjdk.java.net                                    | 源代码（例如编译器、虚拟机、原生方法以及私有辅助类） |
| http://docs.oracle.com/javase/tutorial/getStarted/cupojava | Oracle官方教程                                       |



# Java文件结构与源码编译

## Java编译运行过程

1. 编译期：`.java`源文件，经过编译，生成`.class`字节码文件

2. 运行期：JVM加载`.class`并运行

**相关名词**

- **JVM（Java Virutal Machine，Java虚拟机）**

  它是为了屏蔽底层OS之间的不同差异而存在的程序，JVM本身并不能跨平台

  Java开发的代码不是直接编译成底层OS所需要的执行程序，而是编译成JVM所需要的中间码，这个中间码称为**字节码（`.class`文件）**

- **JRE（JAVA Runtime Environment，JAVA运行环境）**

  包含JVM及运行java程序所必须的环境

- **JDK（Java Development Kit，Java开发工具包）**

  包含JVM、JRE、一些可执行命令（java，javac，jshell，javadoc等）以及第三方的类库

  > 运行java程序的最小环境为JRE
  >
  > 开发java程序的最小环境为JDK

==Java源文件以类名作为文件名，后缀为`.java`，经过编译器编译后，在旁边生成后缀为`.class`的同名字节码文件（内容为二进制机器语言）==



## 命令行工具

**编译源文件：`javac [-option] source_name.java`**

**例如：**`javac HelloWord.java`

> 使用通配符编译源文件：`javac Hello*.java`（编译所有文件名以`Hello`开头的java源文件）



如果源文件在其他文件夹中，使用命令：**`javac dir\dir\...\source_name.java`**

- **`.`**

  当前文件夹

  > `.\file`指向当前文件夹下的文件名为`file`的文件

- **`..`**

  上一级文件夹

  > `..\file`指向当前文件夹的上一级文件夹下的文件名为`file`的文件



**运行程序：`java class_name`**

必须是后缀为`.class`的文件，使用该命令需要去除后缀

**例如：**`java HelloWorld`



> 编译器对文件（带有文件分隔符和扩展名`.java`的文件）进行操作
>
> 而Java解释器加载类（不需要`.class`后缀）
>
> 如果运行包中的类需要使用`.`分隔符而不是文件分隔符
>
> 例如：`java com.xxx.HelloWorld`



## 包

==包用于将类组织起来，让自己的代码与别人提供的代码库分开管理（相当于计算机中的文件系统）==

> Sun公司建议将公司的因特网域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包
>
> 例如：`com.baidu.project`

**从编译器的角度，嵌套的包之间没有任何关系**

> `java.util`与`java.util.jar`毫无关系，每一个都拥有独立的集合



### 类的导入

==一个类可以使用所属包中的所有类，以及其他包中的公有类==

**导入包的两种方式：**

- **在每个类之前添加完整的包名**

  ```java
  class OOP
  {
      java.time.LocalDate today = java.time.LocalDate.now();
  }
  ```

- **使用import语句**

  import语句是一种引用包含在包中的类的简明描述，**一旦使用了import语句，就无需写出包的全名**

  ```java
  import java.time.LocalDate;
  
  class OOP
  {
      LocalDate today = LoacalDate.now();
  }
  ```




使用通配符导入一个包下的所有类：`import java.time.*;`

> 只能使用星号导入一个包，无法使用`java.*`或`java.*.*`导入以java为前缀的所有包



==在发生类名冲突时，就需要注意包名==

```java
// java.util和java.sql中都有日期（Date）类
import java.util.*;
import java.sql.*;
// 如果程序中使用Date类，就会出现编译错误
import java.util.Date; // 增加一个特定的import语句解决报错

class OOP
{
    public static void main(String[] args)
    {
        java.util.Date d1 = new java.util.Date();
        java.sql.Date d2 = new java.sql.Date(...);
        // 如果两个类都需要使用，那就必须在前面添加完整的包名
    }
}
```



### 静态导入

==import语句可以导入静态属性和方法==

```java
import static java.lang.System.*;
import static java.lang.System.out; // 导入指定的属性或方法

class OOP
{
    public static void main(String[] args)
    {
        out.println("Hello World!"); // 此时就可以不写类名前缀直接使用静态属性
    }
}
```



### 将类放入包中

**定义类的所在包：**

在源文件的开头，包中定义类的代码之前写上类所在的包名

```java
package com.xxx; // 定义该类在com.xxx包下

public class HelloWorld
{
    ...
}
```



如果没有在源文件中定义package语句，这个源文件中的类就被放置在**默认包**中，默认包是一个没有名字的包

在此之前，定义的所有类都在默认包中

**包中的文件应该放在与包名匹配的子目录中**

> `com.xxx`包中的源文件应被放置在子目录`com\xxx`中



==若使用命令行工具，编译源文件要在**基目录**中进行==

**例如：**

`PackageTest`类放置在默认包中，`Employee`类放置在`com.company.staff`包中

```java
import com.company.staff.Employee;

public class PackageTest
{
    Employee e = new Employee();
}
```

```java
package com.company.staff;

public class Employee
{
}
```

目录结构为：

```
.（基目录）
	- Package.java
	- Package.class
	- com
		- company
			- staff
				- Employee.java
				- Employee.class
```

这种情况只需要在基目录下编译`javac Package.java`，编译器会自动寻找文件`com\company\staff\Employee.java`并编译



**另一种情况：**

`PackageTest`类放置在`com.othercompany`包中，`Employee`类放置在`com.company.staff`包中

```java
package com.othercompany;

import com.company.staff.Employee;

public class PackageTest
{
    Employee e = new Employee();
}
```

```java
package com.company.staff;

public class Employee
{
}
```

目录结构为：

```
.（基目录）
	- com
		- company
			- staff
				- Employee.java
				- Employee.class
		- othercompany
			- Package.java
			- Package.class
```

这种情况仍然要从基目录编译和运行

`javac com\othercompany\Package.java`

`java com.othercompany.Package`



> 编译器在编译源文件时不检查目录结构
>
> **例如：**一个源文件开头是`package com.mycompany;`，即使这个源文件没有在子目录`com/mycompany`下，也可以进行编译
>
> 如果它不依赖于其他包，那么就不会出现编译错误
>
> 但是，最终的程序将无法执行，除非先将类文件（`.class`文件）移至正确的位置上
>
> 如果包名与目录不匹配，虚拟机就找不到类



## JAR文件

==JAR（Java归档）文件使用ZIP格式组织文件和子目录==

可以使用ZIP程序查看JAR文件结构



## 类路径

可以在编译Java文件时，引用其他文件或JAR包中的类，分为以下步骤：

1. 将类或JAR包放入一个目录中，例如`C:\\users\xxx\classdir`，这个目录是**包树状结构的基目录**

   > 如果要添加`com.company.staff.Employee`类
   >
   > `Employee.class`文件就必须位于子目录`C:\users\xxx\classdir\com\company\staff`中

2. 设置类路径（包含所有类文件的路径的集合，不规定顺序）

   - UNIX环境中，类路径的不同项目之间采用冒号`:`分隔

     `/home/user/classdir:.:/home/user/archives/archive.jar:xxx`

   - Windows环境中以分号`;`分隔

     `C:\user\xxx\classdir;.;xxx\xxx.jar;xxx`

> JavaSE6开始，可以在JAR文件目录中指定通配符
>
> 例如：`C:\classdir;.;C:\archives\*`或`/home/user/classdir:.:/home/user/archives/'*'`
>
> 表示`archives`目录中的所有JAR文件都包含在路径中
>
> 但是在UNIX中，禁止使用`*`以防止shell命令进一步扩展



运行时库文件（`re.jar`和在`jre/lib`与`jre/lib/ext`目录下的一些其他JAR文件）会被自动搜索，所以不必显式的列在类路径中

> javac编译器总是在当前目录中查找文件，但Java虚拟机仅在类路径中有`“.”`目录时才查看当前目录
>
> 如果没有设置类路径，那也不会产生问题，默认的类路径包含`“.”`目录
>
> 但如果设置了类路径却忘记包含`“.”`目录，程序仍然可以通过编译，但不能运行



### 定位类

==类路径所列出的目录和归档文件是搜寻类的起始点==

**例如：**

- **虚拟机定位类：**

  有一个类路径`/home/user/classdir:.:/home/user/archives/archive.jar`

  虚拟机要搜索`com/xxx/Employee`类文件

  1. 查看存储在`jre/lib`与`jre/lib/ext`目录下的归档文件中所存放的系统类文件
  2. 如果系统类文件中没有，则在类路径中查找以下文件：
     - `/home/user/classdir/com/xxx/Employee.class`
     - `com/xxx/Employee.class`（从当前目录开始）
     - `/home/user/archives/archive.jar`中的`com/xxx/Employee.class`

- **编译器定位文件：**

  如果引用了一个类，而没有指出这个类所在的包

  那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类

  **例如：**

  源文件包含指令：

  `import java.util.*;`

  `import com.xxx.*;`

  并且源代码引入了`Employee`类

  编译器将试图寻找`java.lang.Employee`（`java.lang`包被默认导入）、`java.util.Employee`、`com.xxx.Employee`和当前包中的`Employee`，对这个类路径的所有位置中列出的每一个类进行逐一查看

  如果找到了一个以上的类，就会产生编译错误（类必须唯一，而import语句的次序无关紧要）

  > 编译器还需要对比源文件与类文件，如果源文件比类文件新，源文件会自动被重新编译



### 设置类路径

==使用`-classpath`（或`-cp`）选项指定类路径==

例如：`java -classpath /home/user/classdir:.:/home/user/archives/archive.jar HelloWorld`

或：`java -classpath C:\classdir;.;C:\archives/archive.jar HelloWorld`

> 整个命令应该写在一行中（可以放在一个shell脚本或批处理文件中）



**可以通过设置系统环境变量（CLASSPATH）的方式设置类路径，如果运行时不指定类路径，Java会默认去寻找系统的CLASSPATH环境变量中设置的类路径**



# 面向对象

==面向对象（OOP）是一种编程思想==

面向对象的程序由对象组成（万物皆对象），每个对象包含对用户公开的特定功能部分和隐藏的实现部分

用户**只需要调用功能获取数据，而不需要关心功能的具体实现**

> 程序中的对象可以来自标准库，也可以自定义



与之对应的是面向过程（例如C语言）

面向过程的程序通过设计一系列的过程（算法）解决问题，然后考虑存储数据的方式

而面向对象对过程做了进一步封装，将过程视作对象的行为，通过行为可以获取或改变数据，设计时需要首先考虑对象的数据结构

> 对于一些规模较小的问题，分解为过程的开发方式比较合适，而面向对象适合解决规模较大的问题



==面向对象的三大特征：==

- **封装**
- **继承**
- **多态**



## 类

==类是构造对象的模板或蓝图，是一类事物的宏观定义==

> 例如：手机应该有屏幕，有电池，能打电话等

类是Java编程的最小单位，所有的代码都位于某个类中

由类构造对象的过程称为**创建类的实例**



> 不是所有类都具有面向对象特征
>
> 比如`Math`类，只封装了功能，它不需要也不必隐藏数据
>
> 有些类会私有化构造方法，无法创建该类的实例



## 封装

从形式上看，封装是将数据和行为组合在一个包中，并对使用者隐藏了数据的实现方式

对象中的数据称为**实例域（属性）**，操作数据的过程称为**方法**

类的每个实例（对象）都有一组特定的属性值，这些值的集合就是这个对象的当前**状态**



==封装的关键在于绝对不能让类中的方法直接地访问其他类地属性，程序只通过对象的方法与对象数据进行交互，使对象拥有”黑盒“的特征，提高重用性和可靠性==

意味着一个类可以全面地改变存储数据的方式，只要使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化



## 对象

==对象是类的具体实现，是一个真实存在的个体==

> 例如：手中拿着的能够使用的一部手机

**对象的三个主要特征：**

- **对象的行为**

  同一个类的所有对象实例，都具有相同的行为，通过可调用的方法定义

- **对象的状态**

  每个对象描述当前特征的信息（属性），就是对象的状态

  对象的状态可能会随着时间而发生改变，但这种改变不会是自发的，对象状态的改变必须通过调用方法实现

  > 如果不经过方法调用即可改变状态，则说明封装性遭到破坏

- **对象的标识**

  对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份

  > 例如，在一个订单系统中，即使订购的货物完全相同，两个订单也存在着不同之处

==作为一个类的实例，每个对象的标识永远是不同的，状态也常常存在差异==

> **对象的特性之间也会彼此影响着**，例如：如果一个订单标记为”已送货“或”已付款“，就应该拒绝调用修改订单中条目的方法；如果订单是”空的“，即还没有加入预订的商品，这个订单就不应该进入”已送货“状态



## 类之间的关系

类之间常见的关系有：

- **依赖（uses-a）**

  ==如果类A的方法操纵类B的对象，那么这个A依赖于B==

  > 应该尽可能减少相互依赖的类，因为B的改变可能会导致A产生bug
  >
  > 减少依赖可以减少类之间的耦合度

- **聚合（has-a）**

  ==如果类A的对象包含类B的对象，那么类A与类B为聚合关系==

- **继承（is-a）**

  ==如果类A继承自类B，那么类A在拥有自己定义的属性和方法的同时，将包含类B中的所有属性和方法==



# 标识符

==标识符是给Java编程元素**命名**的，它由字母、数字、`_`、`$`组成，并且不以数字开头的字符序列==

==标识符尽量保持有意义，如：`Hello`，`Cup`，`_abc`，`a5`，...==

## Java命名规范

- ==**Java严格区分大小写**==

  例如：class是类定义关键字，Class是官方API中的一个类名

- ==只能包含字母、数字、`_`和`$`符，不能以数字开头==

- ==不能使用关键字==



## Java中的字母和数字

Java中的字母和数字表示的范围很大

- **字母**

  包括'A'\~'Z'、'a'\~'z'、'_'、'$'或在某种语言中表示字母的任何Unicode字符

  > 例如：汉字、日文、π等

- **数字**

  包括'0'\~'9'和在某种语言中表示数字的任何Unicode字符

  **但是'+'和'©'不能用作命名，空格也不行**

> 虽然`$`是合法的字符，但是尽量不要在自己的代码中使用
>
> 它只用在Java编译器或其他工具生成的名字中



## 驼峰命名法

- **大驼峰**

  ==所有单词的首字母为大写==，如CamelCase

  一般用于**类名**

- **小驼峰**

  ==从第二个单词开始首字母大写==，如camelCase

  一般用于**包名、变量名**



# 语句与语句块

==一句话必须以**`;`**结束==



==**语句块**是指由**一对大括号**括起来的若干条语句，一个块可以嵌套在另一个块中==

> 任何可以使用表达式的地方，都可以使用语句块代替

```Java
{
	int a = 0;
	a = a + 1;
}
```



## 作用域

==**变量有效可使用的区域**==

==一个变量只能在当前语句块及其子块中使用==



## 初始化块

==一个类中可以包含多个代码块，只要构造类对象这些块就会被执行==

```java
class OOP
{
	int x;
    
    {
        x = 1;
    }
    // 代码块在每次创建对象时被执行
}
```

> 可以在代码块上加`static`关键字，这样它就属于类，只会在类被加载时执行（类只会被加载一次），不管创建多少对象都不会再执行
>
> 类加载的时机有：
>
> - **创建类对象时**
> - **访问类的静态变量时**
> - **访问类的静态方法**
> - **通过`Class.forName`反射时**
> - **初始化一个类的子类时（会首先初始化子类的父类）**
> - **虚拟机启动时，执行`main()`的类**



# 注释

> 注释在编译器编译源文件时会被舍弃，不会出现在可执行文件中

## 单行注释与多行注释

- 单行注释（`//`）

  **一行内**从`//`向后的内容都会被标注为注释

- 多行注释（`/* */`）

  从`/*`到`*/`中间所有内容都为注释，**可以跨行**

```Java
public class HelloWorld {
    public static void main(String[] args) {
        /*
            这是多行注释
            1
            2
            3
         */
        System.out.println("Hello World!"); // 这是单行注释
        // 这是单行注释
        System.out/* 注释不影响程序编译，但不建议这种注释方式 */.print/* 注释放在这里会导致编译失败 */ln("Hello World!");
        // 注释只能放在单词与单词之间，不能放在单词中
    }
}
```



## 文档注释

==文档注释从`/**`开始，到`*/`结束==



### javadoc

`javadoc`是一个文档生成工具，它可以由源文件生成一个HTML文档（Java官方类库的文档就是由它生成的）



### 插入文档注释

`javadoc`从以下特性中抽取信息：

- **包**
- **公有类与接口**
- **公有的和受保护的构造器及方法**
- **公有的和受保护的属性**

==文档注释应置于以上特性之前==

**文档注释中可以使用HTML标签**，例如\<strong\>...\</strong\>

> **不能使用`h1`和`hr`，它们会与文档的格式产生冲突**
>
> **若要输入代码，可使用`{@code ...}`，这样就不需要关心`<`等字符的转义问题**



#### 标记

文档注释中的标记之后紧跟着**自由格式文本（free-form text）**，==标记由`@`开始==，例如`@author`或`@param`

**自由格式文本的第一句应该是一个概要性句子，`javadoc`自动将这些句子取出来形成概要页**



### 类注释

==类注释必须放在import语句之后，类定义之前==

```java
/**
 * 这是类注释，可以不用在每一行开头添加星号，这是IDE的功能
 */
public class Type
{
    // ...
}
```



### 方法注释

==每一个方法注释必须放在所描述的方法之前==

除了通用标记外，还可以使用：

- `@param`传参描述

  添加一个"param"（参数）条目

  描述方法的参数

  可以占据多行，一个标记对应一个参数

- `@return`返回值描述

  添加一个"return"（返回）条目

  描述方法的返回值

  可以占据多行

- `@throws`抛出异常描述

  描述这个方法有可能抛出的异常

```Java
/**
 * 这是方法注释，该方法是一个加法函数
 * @param x 加法的左操作数
 * @param y 加法的右操作数
 * @return 返回两数之和
 * @throws Exception 该方法会抛出一个异常
 */
public int plus(int x, int y) throws Exception
{
    return x + y;
}
```



### 属性注释

==一般只需要对公有属性（通常是静态常量）建立文档==

```java
/**
 * 这是属性注释
 */
public static final int NUM = 1;
```



### 通用注释

**以下标记可以用在类文档注释中：**

- `@author`姓名

  添加一个"author"（作者）条目

  可以使用多个`@author`标记，每个标记对应一个作者

- `@version`文本

  添加一个"version"（版本）条目

  描述当前版本

**以下标记可以用于所有文档注释中：**

- `@since`文本

  添加一个"since"（始于）条目

  描述第一次引入该特性的版本，例如`@since version 1.7.1`

- `@deprecated`文本

  对类、方法或变量添加一个不再使用的注释，文本中给出取代的建议

  **例如：**`@deprecated Use <code> setVisible(ture) </code> instead`

**通过`@see`和`@link`标记，可以使用超链接，链接到`javadoc`文档的相关部分或外部文档**

- `@see`引用

  在"see also"部分增加一个超链接，它可以用于类或方法中

  这里的引用可以选择下列情形之一：

  - *`package.class#feature label`*

    提供类、方法或变量的名字，`javadoc`会在文档中插入一个超链接

    > **例如**：`@see com.xxx.Employee#raiseSalary(double)`
    >
    > 建立一个链接到`com.xxx.Employee`类的`raiseSalary(double)`方法的超链接
    >
    > 可以省略包名，或将包名和类名都省略，链接将定位当前包或当前类

    ==一定要使用`#`，而不是调用符号`.`==

    如果`@see`标记后面有一个`<`，那么就需要指定一个超链接，可以链接到任何URL

    例如：`@see <a href="www.baidu.com">xxx</a>`

  - *`<a href="...">label</a>`*

  - *`"text"`*

  `label`是一个链接锚，如果省略`label`，用户看到的就是目标代码名或URL

  ==可以为一个特性添加多个`@see`，但必须将它们放在一起==

- 可以在注释中的任意位置放置超链接或插入一个专用的标记

  > 例如：*`{@link package.class#feature lable}`*，这里的特性描述规则于`@see`相同



### 包与概述注释

==添加包注释，需要在每一个包目录中添加一个单独的文件==

有两种选择：

- 提供一个以`package.html`命名的HTML文件，在`<body>...</body>`中的内容都会被抽取出来

- 提供一个以`package-info.java`命名的Java文件

  这个文件必须包含一个初始的以`/**`和`*/`界定的Javadoc注释，**跟随在一个package语句之后**

  它不能包含更多的代码或注释



**概述性注释：**

这个注释被放置在一个名为`overview.html`的HTML文件中，这个文件位于包含所有源文件的父目录中

标签`<body>...</body>`中的内容会被抽取出来

当用户从导航栏中选择"Overview"时，就会显示这些注释内容



### 注释的抽取

执行以下步骤：

1. 切换到想要生成文档的源文件目录，如果有嵌套的包要生成文档，则切换到包含这个包的目录

2. 运行命令：

   - `javadoc -d docDirectory packageName`

     生成一个包的文档

   - `javadoc -d docDirectory package1Name package2Name ...`

     生成多个包的文档

   - `javadoc -d docDirectory xxx.java`

     生成某个源文件的文档

   > `docDirectory`是生成后的HTML文档所在的目录，如果省略了`-d docDirectory`，那么HTML文档就会被提取到当前目录下（可能会造成混乱）



**常用控制选项：**

- `-author`或`-version`

  在文档中包含`@author`和`@version`标记（默认情况下会被省略）

- `-link`

  为标准类添加超链接

  > 例如：`javadoc -link http://docs.com/javase/8/docs/api *.java`
  >
  > 使所有标准类库类自动链接到Oracle网站的文档

- `-linksource`

  每个源文件被转换为HTML（不对代码着色，但包含行编号），并且每个类和方法名将转变为指向源代码的超链接

> 更多选项可以查阅官方文档
>
> 如果需要进一步定制，例如生成非HTML格式的文档，可以提供自定义的`doclet`，相关操作需要查阅官方文档



# 关键字

> **受限关键字：**
>
> 它们只在特定场合（例如模块声明中）有特殊含义，在其他情况下可作为标识符使用
>
> **保留字：**
>
> 某些关键字没有任何意义，未被使用，只是被Java占用了



**Java 关键字：**

|   关键字   |                   含义                   |    关键字    |                            含义                            |
| :--------: | :--------------------------------------: | :----------: | :--------------------------------------------------------: |
|  abstract  |               抽象类或方法               |     new      |                    分配一个新对象或数组                    |
|   assert   |           用来查找内部程序错误           |     null     |    一个空引用（null从技术上讲是一个字面量，而非关键字）    |
|  boolean   |                 布尔类型                 |    module    |                  声明一个模块**（受限）**                  |
|   break    |          跳出一个选择语句或循环          |     open     |               修改一个module声明**（受限）**               |
|    byte    |               8位整数类型                |    opens     |                打开一个模块的包**（受限）**                |
|    case    |             switch的一个分支             |   package    |                       包含类的一个包                       |
|   catch    |           捕获异常的try块子句            |   private    |                这个特性只能由该类的方法访问                |
|    char    |             Unicode字符类型              |  protected   | 这个特性只能由该类、其子类以及同一个包中的其他类的方法访问 |
|   class    |              定义一个类类型              |   provides   |            只是一个模块使用一个服务**（受限）**            |
|   const    |                **未使用**                |    public    |               这个特性可以由所有类的方法访问               |
|  continue  |              在循环末尾继续              |    return    |                       从一个方法返回                       |
|  default   |   switch的默认子句，或者接口的默认方法   |    short     |                        16位整数类型                        |
|     do     |         do/while循环最前面的子句         |    static    |         这个特性是类或接口特有的，而不属于类的实例         |
|   double   |             双精度浮点数类型             |   strictfp   |                 对浮点数计算使用严格的规则                 |
|    else    |             if语句的else子句             |    super     |            超类对象或构造器，或一个通配符的下界            |
|    enum    |                 枚举类型                 |    switch    |                        一个选择语句                        |
|  exports   |       导出一个模块的包**（受限）**       | synchronized |               对线程而言是原子的方法或代码块               |
|  extends   |  定义一个类的父类，或者一个通配符的上界  |     this     |             当前类的一个方法或构造器的隐含参数             |
|   final    |   一个常量，或一个不能被覆盖的类或方法   |    throw     |                        抛出一个异常                        |
|  finally   |          try块中总会执行的部分           |      to      |           exports或opens声明的一部分**（受限）**           |
|   float    |             单精度浮点数类型             |    throws    |                   一个方法可能抛出的异常                   |
|    for     |               一种循环类型               |  transient   |                      标记非永久的数据                      |
|    goto    |                **未使用**                |  transitive  |             修饰一个 requires 声明**（受限）**             |
|     if     |               一个条件语句               |     try      |                      捕获异常的代码块                      |
| implements |           定义一个类实现的接口           |     uses     |            指示一个模块使用一个服务**（受限）**            |
|   import   |                导入一个包                |     var      |         声明一个变量的类型是推导得出的**（受限）**         |
| instanceof |      测试一个对象是否为一个类的实例      |     void     |                  指示一个方法不返回任何值                  |
|    int     |               32位整数类型               |   volatile   |               确保一个字段可以由多个线程访问               |
| interface  | 一种抽象类型，其中包含可以由类实现的方法 |     with     |         在一个provides语句中定义服务类**（受限）**         |
|    long    |              64位长整数类型              |    while     |                          一种循环                          |
|   native   |         由宿主系统实现的一个方法         |              |                                                            |



## 访问控制修饰符

==访问控制修饰符可以定义在类、属性、方法上==

- **public**

  公开的，任何类都可以访问

- **private**

  私有的，只有本类可以访问

- **protected**

  受保护的，本类、派生类、同包类可以访问

  *应用率低*

- **默认的**：什么也不写

  本类、同包类可以访问

  *不建议使用默认权限*

  > ==类的访问权限，只能是public或默认，类中成员可以是上面四种中的任意一种==
  >
  > **访问权限由低到高依次为：**private < 默认的 < protected < public



# 函数

Java 中一般称为==**方法**==

**格式**：`[访问修饰符] 返回值类型 方法名([参数类型 参数名][, 参数类型 参数名][, ...]) {方法体}`

```Java
public int plus(int a, int b)
{
    int c = a + b;
    return c;
}
```

==方法必须标注返回值类型，如果没有返回值，则在返回值类型处使用`void`关键字==

**方法可以没有参数，也可以有一个或多个参数，即使一个方法没有参数，也需要使用空括号**

```Java
void run()
{
    // 方法体
}
```



## return

==用于结束方法，如果有返回值，将要返回的变量放在return后面==

> 方法只要运行到return就会结束，不论后面还有没有代码未执行

也可以返回一个表达式，返回值为表达式的值

```Java
public int plus(int a, int b)
{
    return a + b; // 计算a+b并返回
}

public void user()
{
    int x = 1;
    int y = 2;
    int z = plus(x, y); // z == 3
}
```



## main方法

==Java虚拟机总是从指定类中的**main方法**开始执行==

**main方法的格式是固定的，是一个公开的静态无返回值方法，参数为一个String数组**

```Java
public class HelloWorld
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
```



main方法的参数为一个字符串数组，包含了使用控制台运行程序时的命令单词

> **例如：**
>
> 使用命令：`java HelloWorld -h Hello Java`
>
> 数组`args`的内容为：`{"-h", "Hello", "Java"}`



## 隐式参数与显式参数

> 局部变量与属性名称相同时，方法内默认使用局部变量（局部优先原则）

==所有的非静态方法都有一个隐式参数，它的值为该对象本身（如果是构造方法，其值为即将创建的对象本身），显式参数则为方法名后面括号中的数值==

**隐式参数使用关键字`this`表示**

```java
public class OOP
{
	private int i;

	public OOP(int i)
	{
        // i = i; // 前后都是方法传入的局部变量i，没有意义
		this.i = i; // 前者表示方法的调用者内部的属性i，后者表示传入的局部变量i
	}
}
```

> 隐式参数也可以称为方法调用的目标或接收者



## 方法重载

**方法签名：**

方法名与参数列表的组合称为**方法的签名**

==只有两个方法的方法名与参数列表的组合完全相同时==，编译器才会认为两个方法相同，然后报错



**方法名相同，参数列表不同的情况被称为==方法重载==**

> 调用方法时，编译器依照方法签名挑选和调用方法
>
> **如果方法名相同，会根据传入的参数个数与类型挑选方法**

```JAVA
class OOP
{
    OOP() {}
    OOP(int i) {} // 构造器也可以重载
    
    public int plus(int a, int b) {return a + b;}
    public int plus(int a, int b, int c) {return a + b + c;}
    private void plus(int a, double b) {}
    
    //private void plus(int x, int y) {} // 编译错误，方法签名与第一个方法完全相同
}
```



## 构造器

> 构造器是特殊的**方法**，用于构造并初始化对象

==构造器的名字必须与类名相同，可以在类外部直接被调用，且总是伴随着`new`操作符==

例如：`new HelloWorld()`



> 可以将这个对象当作参数传递：
>
> `System.out.println(new HelloWorld());`
>
> 也可以直接调用该对象的方法：
>
> `String s = new HelloWorld().toString();`



**将对象存储到变量中时，该变量的声明类型必须为该类或该类的超类**

`HelloWorld hello = new HelloWorld();`



**如果一个类没有构造器，那么系统会默认添加一个无参构造器**

**如果提供了至少一个有参构造器，那么系统不会自动添加无参构造器，构造对象时就必须传入参数**

> 在构造器执行完后，所有的常量属性必须被手动赋过值，而变量如果没有被赋值，会被系统**赋默认值**
>
> 被`static final`修饰的静态常量必须在声明的同时赋值

```java
class OOP
{
    int x; // x会在构造器执行完后被系统赋值0
    // static final int A; // 编译错误，静态常量必须在声明时手动初始化
    static final int B = 0;
    // final int a; // 编译错误，必须手动初始化
    final int i;
    OOP()
    {
        i = 1;
    }
}
```



构造器中的第一句如果是`this(...)`，那么会调用类中的另一个重载的构造器，只需要参数能够对应上

> `this(...)`只能出现在构造器的第一句



## 更改器方法与访问器方法

顾名思义，==修改对象状态的方法称为更改器方法，而只访问对象状态的称为访问器方法==

**一般情况下，类中的属性都会设置为私有属性（被`private`修饰符修饰），通过更改器与访问器修改与访问**

> 有些看似改变状态的方法，其实是返回了一个新的对象，而原对象内部状态并没有改变
>
> **例如：**
>
> String类的`toUpperCase`方法，只是获取了字符串的字母然后转换为大写形式存储在一个新的字符串对象中，原本的字符串并没有发生改变



### getter/setter方法

**更改器方法与访问器方法的一种命名方式**

**例如：**

```Java
public class OOP
{
    private int a;
    private int b;
    
    public int getA() {return a;} // getter方法，访问器
    public void setB(int i) {b = i;} // setter方法，更改器
}
```



## 按值调用与按引用调用

> 按...调用（call by）是一个标准的计算机科学术语，用于描述各种程序设计语言中方法参数的传递方式
>
> 曾经还有按名调用，古老的Algol程序设计语言使用的就是这种方式，现在已经过时

Java采用的是按值引用，==方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容==

**对于基本类型，修改局部变量的值并不能原变量；而对于对象类型，由于对象变量只是对于一个对象的引用，所以局部变量引用另一个对象不会影响原原变量，但是修改变量属性值会影响到原变量的属性**

```Java
static void tripleValue(int x) {x *= 3;}
// 调用这个方法
int i = 10;
tripleValue(i); // 局部变量x值为30，但是其作用域只在方法体内，原变量i的值依然是10

static void change(Employee x) {x = new Employee;} // 更改x的引用不会影响原变量的引用地址

static void doubleSalary(Employee x) {x.setSalary(x.getSalary * 2);} // 原变量的salary值最后会变成两倍
```

> 因为局部变量得到的只是对象的引用地址，所以可以改变该地址内的对象的内部属性

**总结：**

- 一个方法不能改变一个基本数据类型的参数
- 一个方法可以改变一个对象参数的状态
- 一个方法不能让一个对象参数引用一个新的对象



## 对象析构与`finalize`方法

有些面向对象的程序设计语言（例如C++），有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码

在析构器中，最常见的操作是回收分配给对象的存储空间

由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器



`Object`类中有一个`finalize`方法，它会在垃圾回收器清除对象之前调用，在Object中，该方法的方法体内没有任何代码，可以通过重写添加代码

> ==尽量不要依赖`finalize`方法回收任何短缺的资源，因为很难知道对象会在什么时候被垃圾回收器回收，调用该方法的时间自然也是不确定的==



## 对象方法调用的细节

假设要调用`x.f(args)`，隐式参数x声明为类C的一个对象，调用过程：

1. ==编译器查看对象的声明类型和方法名==

   > 有可能存在多个名字为`f`，但参数类型不一样的方法，例如：可能存在方法`f(int)`和方法`f(String)`
   >
   > 编译器会一一列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）

   **这一步编译器会获得所有可能被调用的候选方法**

2. ==编译器查看调用方法时提供的参数类型==

   如果在所有名为`f`的方法中存在一个与提供的参数类型完全匹配，则选择这个方法，这个过程称为**重载解析**

   > 由于允许类型转换（int转换为double，子类转换为超类等），这个过程可能很复杂

   如果编译器没有找到与参数类型匹配的方法，或者经过类型转换后有多个方法与之匹配，就会报告一个错误

   **这一步编译器会获得需要调用的方法名字和参数类型**



如果方法被`private`、`static`、`final`修饰，或者该方法为构造器方法，编译器可以准确地知道应该调用哪个方法，这种调用方式称为**静态绑定**

而**动态绑定**就是自动选择调用哪个方法，动态绑定==依赖于隐式参数实际类型，并且在运行时实现==



当程序运行，并采用动态绑定调用方法时，虚拟机一定调用与`x`所引用对象的实际类型最合适的那个类的方法

> 假设`x`的实际类型是D，它是C类的子类
>
> 如果D类定义了方法`f(String)`就直接调用，否则将在D类的超类中寻找`f(String)`，以此类推



每次调用方法都进行搜索，时间开销会非常大

**虚拟机预先为每个类创建了一个方法表，其中列出了所有方法的签名和实际调用的方法**，在调用方法时只需要查找这个表

> 如果调用`super.f(...)`，编译器会对隐式参数的超类的方法表进行搜索



# 数据类型

==Java是一种**强类型语言**，必须为每一个变量声明一种类型==

## 基本类型

### 整型

> 默认值为0，long类型默认值为0L

==没有小数部分的值，允许为负数==

| 类型  | 存储需求 | 取值范围                                                     |
| ----- | -------- | ------------------------------------------------------------ |
| int   | 4字节    | -2147483648 ~ 2147483647（-2^31^ ~ 2^31^ - 1）               |
| short | 2字节    | -32768 ~ 32767（-2^15^ ~ 2^15^ - 1）                         |
| long  | 8字节    | -9223372036854775808 ~ 9223372036854775807（-2^63^ ~ 2^63^ - 1） |
| byte  | 1字节    | -128 ~ 127（-2^7^ ~ 2^7^ - 1）                               |

- 两个整数相除，结果还是整数，**小数位无条件舍弃**(不会四舍五入)

  ```Java
  int i = 5 / 2; // 结果为2
  ```

- 若超过各类型的取值范围（过大或过小），会产生溢出，不会通过编译

  **运算时发生溢出不会产生错误，但需要避免，因为会导致结果出错**

  ```Java
  int b = 10000000000; // 编译错误，超出int范围
  int d = 2147483647; // int的最大值
  d = d+1; // 结果为-2147483648，发生溢出了，溢出需要避免
  ```

- 不管声明时为什么类型，赋值整数时**默认为`int`类型**

  `long`类型需要加后缀`L`或`l`，short和byte类型需要强转

  ```Java
  long l = 10000000000; // 编译错误，需要加L或l后缀
  long l = 10000000000L;
  byte b = 10; // 编译错误，需要强转
  byte b = (byte) 10;
  short s = (short) 1000;
  ```

- 十六进制数值使用前缀`0x`或`0X`

  八进制使用前缀`0`

  Java7之后可以使用前缀`0b`或`0B`表示二进制

  ```Java
  int i = 1L; // long类型
  int i = 0XCAFE; // 十六进制
  int i = 010; // 八进制
  int i = 0B10; // 二进制
  ```

- 数字可以使用下划线`_`，下划线在编译时会被去除

  ```Java
  int i = 1000_000; // 相当于1000000
  ```

> 所有不分大小写的前缀与后缀都建议大写



### 浮点型

> 默认值为0.0

| 类型   | 存储需求 | 取值范围                                       |
| ------ | -------- | ---------------------------------------------- |
| float  | 4字节    | 约 ±3.40282347E+38F（有效位数为6~7位）         |
| double | 8字节    | 约 ±1.79769313486231570E+308（有效位数为15位） |

- `double`类型的精度是`float`类型的两倍，所以`float`类型一般称为**单精度浮点数类型**，`double`类型一般称为**双精度浮点数类型**

- 浮点型默认为`double`类型，`float`类型需要加后缀`F`或`f`，`double`类型可添加后缀`D`或`d`

- 因为计算机采用二进制，而二进制无法精确表示某些浮点数，如1/10

  就像十进制无法精确表示1/3

  在计算这些数时会有很小的误差，**尽量不要用浮点数类型做比较**

  ```java
  double d = 2.0 - 1.1; // 结果为0.8999999999999999
  ```



**表示溢出和出错情况的三个特殊浮点数值：**

- 正无穷大

  `Double/Float.POSITIVE_INFINITY`

- 负无穷大

  `Double/Float.NEGATIVE_INFINITY`

- NaN（Not a Number，不是一个数字）

  `Double/Float.NaN`

> **所有“非数值”的值都被认为是不相同的，不可以使用`==`判断一个值是否为`NaN`**
>
> 包装类提供了`isNaN(value)`静态方法



### char类型

> 默认值为'\u0000'

用于表示**单个字符**，必须置于单引号中，例如`'A'`

Java中的字符采用**Unicode编码格式**，==一个字符变量存储一个**代码单元**==，本质上是正整数（占用2个字节，0到65535）

（ASCII码：'a'-97	'A'-65	'0'-48）

```java
char c1 = '女'; // 字符女
char c2 = 'f'; // 字符f
char c3 = '6'; // 字符6
char c4 = '*'; // 字符*
//char c5 = 女; // 编译错误，字符直接量必须放在单引号中
//char c6 = ''; // 编译错误，必须有字符
//char c7 = '10'; // 编译错误，只能有一个字符
char c8 = 65; // 字符A
char c9 = '\u0041'; // 字符A
```



#### Java中的字符编码

> ==Java使用16位的Unicode字符集==

**码点：与一个编码表中的某个字符对应的编码值**

在Unicode标准中码点采用十六进制书写，并加上`U+`，例如`U+0041`就是字母A的码点

> Unicode的码点可以分为17个代码级别
>
> 第一个代码级别称为**基本的多语言级别（basic multilingual plane）**，码点从`U+0000`到`U+FFFF`，其中包含经典的Unicode代码
>
> 其余的16个级别码点从`U+10000`到`U+10FFFF`，其中包括一些辅助字符



`UTF-16`编码采用不同长度的编码表示所有Unicode码点

在基本的多语言级别中，每个字符用16位表示，通常被称为**代码单元**

而辅助字符采用一对连续的代码单元进行编码，这样构成的编码值落入基本的多语言级别中空闲的2048字节内，通常被称为**替代区域**（`U+D800`\~`U+DBFF`用于第一个代码单元，`U+DC00`\~`U+DFFF`表示第二个代码单元）

> 例如：`𝕆`是八元数集的一个数学符号，码点为`U+1D546`，编码为两个代码单元`U+D835`和`U+DD46`
>
> 维基百科中对于编码算法的具体描述：http://en.wikipedia.org/wiki/UTF-16



#### 转义序列

| 转义序列 | 名称 | Unicode值 | 转义序列 | 名称   | Unicode值 |
| -------- | ---- | --------- | -------- | ------ | --------- |
| \b       | 退格 | \u0008    | \\"      | 双引号 | \u0022    |
| \t       | 制表 | \u0009    | \\'      | 单引号 | \u0027    |
| \n       | 换行 | \u000a    | \\\      | 反斜杠 | \u005c    |
| \r       | 回车 | \u000d    |          |        |           |

> **Unicode 转义序列会在解析代码之前得到处理**
>
> 例如：
>
> `"\u0022+\u0022"`并不会被编译为`"+"`
>
> `\u0022`会在解析之前转换为`"`，编译完会得到`""+""`，也就是一个空字符串



### boolean类型

`boolean（布尔）`类型只有两个值：`false`和`true`，用来判定逻辑条件

> 布尔值不可以和整数值互相转换



## 对象类型

> 所有对象类型的默认值为null

一种**复合类型**，采用`class`关键字定义，主要有两大类：

- 由`JRE`自带的类型

  例如：`java.lang.String`

- 由程序员自定义的类型



==任何对象变量都不是对象本身，而是对存储在内存中的对象的引用，`new`操作符的返回值也是一个引用，打印对象变量时可以得到对象在内存中的地址==

> 可以把变量值看作一个容器，变量名只是一个指向容器的指示器，它的值为容器存放的地址
>
> 修改变量值相当于指示器指向另一个容器，修改对象属性值相当于修改容器内的物品，两者是完全不同互不相干的操作
>
> 
>
> 而基本类型可以看作一个不可变对象，这个对象本身是一个整体，不可以改变内部属性
>
> 所以基本类型变量不需要指示器，每一个值都是一个常量，变量名可以直接引用变量值

```java
public class Main
{
    public static void main(String[] args)
    {
        final int i;
        i = 1;
        // i = 2; // 编译错误，final修饰的变量不能被修改
        
        final OA oa = new OA();
        oa.a = 1; // 编译成功
    }
}

public class OA
{
    int a = 0;
}
```



**如果对象类型变量被声明而没有引用一个对象，那么它就不能调用任何方法**

```Java
Date deadline;
// String s = deadline.toString(); // 编译错误，因为deadline此时没有引用任何对象
deadline = new Date();
String s = deadline.toString(); // 当前系统日期
```

> 可以显示的设置对象变量为null，表示这个变量目前没有任何引用对象
>
> `Date deadline = null;`
>
> 此时该变量可以调用方法，但是会抛出异常
>
> ```java
> Date deadline = null;
> String s = deadline.toString(); // 编译通过，但是运行到此处会抛出NullPointerException，因为此时deadline的值为null
> ```



**创建对象的具体过程：**

1. 所有属性被初始化为默认值（不管有没有赋值）
2. 按照在类中声明的次序，一次执行属性初始化与初始化块（这时才会给属性附上自定义的值）
3. 如果构造器第一行调用了第二个构造器，则先执行第二个构造器（先执行被调用的构造器）
4. 执行这个构造器

### 静态属性与静态方法

==被`static`修饰符修饰的属性或方法称为静态属性或静态方法==

静态属性和方法如果被设为`public`，可以直接使用通过类调用

```java
public class A
{
	public static int a = 0;
    public static void plus() {a++;}
}

public class B
{
    public static void main(String[] args)
    {
        A.plus();
        int a = A.a;
    }
}
```



#### 静态属性

==类中的每一个实例都共享静态属性的值，任何一个对象的方法修改了这个值，其他对象访问时也会得到修改后的值==

> 也可以说静态属性属于类，而不属于任何独立的对象



#### 静态方法

==静态方法没有隐式参数，不能使用`this`关键字==

所以，静态方法不能直接访问非静态属性与方法

> 静态方法可以被对象调用，但是一般使用类调用，因为静态方法的执行过程与结果可能与对象无关



### 包装类



### String

**字符串类**

==`String`类内置了一个被`final`修饰的`char`数组==

==`String`类本身也被`final`修饰，不能被继承，且未提供修改`char`数组的方法，所以字符串是不可变的==

> 字符串"java"是以['j', 'a', 'v', 'a']的形式存储在一个String对象的value属性中

Java为String类型单独设置了创建对象的方式：被**双引号**包裹的字符串即为一个==String**常量**对象==

> ==`""`也是一个字符串对象，它的`char`数组为空，是个空字符串==



#### 子串

使用String类的`subString`方法能偶==以一个字符串的一部分创建一个新的字符串，原字符串不变==

该方法有两种传参方式：

- `subString(int beginIndex)`

  获取从字符串内置数组的下标为`beginIndex`位置处开始往后所有字符的内容

  ```java
  String s = "Hello";
  String sub = s.subString(2);
  // sub："llo"
  ```

- `subString(int beginIndex, int endIndex)`

  获取从字符串内置数组的下标为`beginIndex`位置到下标为`endIndex`位置中间的内容（不包含`endIndex`）

  ```java
  String s = "Hello";
  String sub = s.subString(0, 3);
  // sub："Hel"
  ```



#### 字符串连接

==Java为`String`类型单独重载了`+`==

在使用`+`时，若其中一个操作数为`String`类型，会自动调用另一个操作数的`toString`方法，然后连接两个字符串

- **空字符串`""`是长度为0、内容为空的字符串对象**
- **`+`运算顺序为从左往右，所以表达式中有多个`+`时，直到有字符串参与才会变为字符串连接**

```java
String s = "Hello" + "World"; // HelloWorld
String s = "" + 1 + 2; // 12
String s = 1 + 2 + "" + 3; // 33
```



#### 字符串比较

- ```java
  String a = "java";
  String b = "java";
  // a == b结果为true
  ```

- ```java
  String a = "Hello";
  String b = "HelloJava";
  String c = a + "Java";
  // b == c结果为false
  ```

- ```Java
  final String a = "Hello";
  String b = "HelloJava";
  String c = a + "Java";
  // b == c结果为true
  ```

- ```Java
  String a = "HelloJava";
  String b = new String("HelloJava");
  // a == b结果为false
  ```

- ```Java
  final String a = "Hello";
  String b = "HelloJava";
  String c = new String(a + "Java");
  // b == c结果为false
  ```



==`String`重写了`equals`方法，该方法会去比较内置的`char`数组，所以尽量使用该方法比较字符串==

> boolean b = s.equals(t);
>
> s可以是字符串变量，也可以是字符串字面量
>
> 例如："Hello".equals(s);
>
> 当调用者有可能为空时可以使用这种方法确保不会出现空指针异常



#### 字符串构建

在一个表达式中需要多次连接字符串时，每连接一次就会创建一个String对象，耗时且浪费空间

可以使用字符串构建工具类：

- `StringBuilder`（不支持线程安全）
- `StringBuffer`（支持线程安全，绝大部分方法都添加了锁，所以性能略低）

```Java
StringBuilder builder = new StringBuilder();
builder.append("Hello");
builder.append("World");
String s = builder.toString();
```



### 大数值

`java.math`包下有两个类，分别表示整型和浮点型：`BigInteger`和`BigDecimal`

==基本的整数类型和浮点类型都有范围限制，而这两个类可以处理包含任意长度数字序列的数值==

> `BigInteger`实现了任意精度的整数运算，`BigDecimal`实现了任意精度的浮点数晕眩
>
> **`BigDecimal`完全没有误差**



由于是对象类型，且Java没有为它们重载运算符，所以**不能使用运算符进行运算**

需要使用类中的方法，如`add`和`multiply`



## 数组

> 数组的本质是对象类型，默认值为null

==数组是一种数据结构，用来存储同一类型值的集合（可以是基本类型，也可以是对象类型）==

声明数组的三种方式：

- `type[] t = new type[num];`

  `num`为数组的容量，表示创建一个容量为num、值类型为type的数组，并为每个元素赋**默认值**

- `type[] a = new type[] {var1, var2, var3, ...}`

  声明的同时为每个元素赋值，容量为大括号内元素数量（若大括号内没有元素，则创建一个空数组）

- `type[] a = {var1, var2, var3, ...}`

  第二种方法的简写

> 声明时，中括号可以写在类型后面，也可以写在变量名后面
>
> `type[] t;`或`type t[];`
>
> 一般使用前者



==数组的容量是不可变的，数组有一个公开属性`length`，它的值为数组容量==

> `java.util.Arrays`
>
> 数组修改元素个数只能通过创建新的数组并复制内容实现
>
> Arrays类是Java提供的操作数组的工具类



==通过下标可以访问数组中的每一个值（数组下标从0开始，第一个元素下标为`0`，最后一个元素下标为`length-1`）==

> 若`a`为一个整型数组，`a[i]`为数组中下标为`i`的整数

```Java
int[] a = {1, 2, 3, 4, 5};
// a[0]为1，a[1]为2...
// 访问a[5]会抛出ArrayIndexOutOfBoundsException（数组下标越界异常）
```



### 多维数组

==多维数组的本质为数组嵌套==

```Java
// 二维数组
int[][] x = {
	{1, 2, 3, 4, 5},
	{6, 7, 8, 9, 10}
}
// x[0][1]为第一个数组的第2个元素2，x[1][3]为9

// 三维数组
int[][][] y = {
    {{1, 2, 3}, {4, 5, 6}},
    {{7, 8, 9}, {10, 11, 12}},
    {{13, 14, 15}, {16, 17, 18}}
};

// 不规则数组
int[][] z = {
    {1, 2, 3, 4, 5},
    {6, 7, 8}
}
// 访问y[1][3]会抛出数组下标越界异常
```



## 类型转换与强制类型转换

==小范围类型转为大范围类型时，系统会自动进行转换==

- `byte -> short -> int -> long`
- `float -> double`
- `int/long -> float/double`

**进行二元计算时：**

- 若一个操作数为`double`类型时，另一个操作数会转换为`double`类型
- 若一个操作数为`float`类型时，另一个操作数会转换为`float`类型
- 若一个操作数为`long`类型时，另一个操作数会转换为`long`类型
- 否则两个操作数都会转换为`int`类型（`short`类型和`byte`类型都会自动转为`int`）



==大范围类型转为小范围类型时，需要使用强制类型转换==

**在数据或表达式前加上`()`，括号中填写要转换的类型**

==**强转有可能丢失精度**==

```Java
int i = (int) 1.5; // 结果为1
int i = (int) 1.0 + 1.0; /* 强转优先级比运算符高，这里会将前一个1.0转换为int值1，但是第二个依然是double类型，int与double相加结果为	double类型，编译错误 */
int i = (int) (1.0 + 1.0);
```



# 变量

## 变量

==变量的值在运行过程中可以变化==

### 声明变量

**格式**：`数据类型 变量名;`

**举例**：`int a;`



**可以在一条语句中声明多个变量**：

`int a, b, c;`*不提倡这种风格*



### 变量初始化

==使用赋值语句对变量进行初始化，没有初始化的变量被使用会导致编译器出错==

**格式**：`变量名 = 值;`

**举例**：`int a;`

​			`a = 0;`

**`=`是赋值符号**



**可以在一条语句中进行声明与赋值**：

`int a = 0;`

> 变量的声明尽量靠近第一次使用的地方，这是一种良好的编程习惯



## 常量

==常量是值不可变的变量==

==在声明时使用`final`关键字修饰的变量被称为**常量**（常量名一般使用全大写，单词之间使用`_`隔开==

**格式**：`final 数据类型 变量名 = 值;`

**举例**：`final int VAR_VALUE = 0;`

> 关键字`final`表示这个变量只能被赋值一次



**`final`限制的是变量的引用**

基本类型变量无法再引用另一个字面量，对象类型无法再引用另一个对象



**如果一个属性被`final`修饰，必须确保构造器执行之后，这个属性被赋过值，且在之后的操作中，不能再对它进行修改**

> `final`修饰符一般应用于基本类型属性，或不可变类的属性（如果类中的所有方法都不会改变其对象，这种类就是不可变类）



**静态常量：**

==被`static final`修饰的属性必须在声明的同时赋值==



## 字面量

==字面量就是字面表达的量，用来给变量或常量赋值==

> 例如：5，18，4.5，'我'，"我们"，"你"，true，false，...

由于计算机字符编码与人理解的字符值不同，程序需要知道字符表示的值

Java会在**常量池**中存储字符与其字面表示的值，**字符串对象也会作为字面量存储**

> 例如：定义`int i = 1;`时，Java会在常量池中查询字符'1'表示的值，然后赋值给变量i



## 枚举

==枚举是一个类，用**关键字`enum`**修饰==



# 运算符

> 操作数只有一个的运算符可以称为单目/单元运算符
>
> 有两个可以称为双目/二元运算符
>
> 有三个可以称为三目/三元运算符

**运算符优先级：**

| 运算符                                                       | 结合性   |
| ------------------------------------------------------------ | -------- |
| `[]`、`.`、`方法调用()`                                      | 从左到右 |
| `!`、`~`、`++`、`--`、`整数符号+`、`负数符号-`、`强制类型转换()`、`new` | 从右向左 |
| `*`、`/`、`%`                                                | 从左向右 |
| `+`、`-`                                                     | 从左向右 |
| `<<`、`>>`、`>>>`                                            | 从左向右 |
| `<`、`<=`、`>`、`>=`、`instanceof`                           | 从左向右 |
| `==`、`!=`                                                   | 从左向右 |
| `&`                                                          | 从左向右 |
| `^`                                                          | 从左向右 |
| `|`                                                          | 从左向右 |
| `&&`                                                         | 从左向右 |
| `||`                                                         | 从左向右 |
| `?:`                                                         | 从右向左 |
| `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`、`>>>=` | 从右向左 |



## 算术运算符

**`+、-、*、/、%、++、--`**

- `%`：取模/取余，余数为0即为整除

- `++/--`：自增1/自减1，可在变量前也可在变量后

  - 在前面时，先执行再代入数值

  - 在后面时，在整句代码结束后执行

    ```Java
    System.out.println(a++); // 输出为结果为a，这一句语句结束后a的值+1
    System.out.println(++a); // 输出结果为a+1
    ```

  > `++/--`要与`+/-`区分开
  >
  > **只要使用了语句中使用了`a++/++a/a--/--a`，a的值一定发生变化，而使用`a + 1`或`a - 1`的形式代入语句，a的值并不会发生变化**
  >
  > 因此，自增/自减运算符的操作数不能为字面量，字面量的值无法更改，例如`4++`



==整数被0除会抛出一个异常，而浮点数被0除会得到`无穷大`或`NaN`==

> **`strictfp`关键字**
>
> 被`strictfp`修饰的方法或类中会使用严格的浮点运算，有可能发生浮点溢出
>
> 例如：将main方法设置为strictfp，则main方法中的浮点运算操作都会使用严格的浮点运算，而在类上标记strictfp，则该类中的所有方法都会使用严格的浮点运算



## 关系运算符与逻辑运算符

==关系与逻辑运算符的返回结果为boolean类型==

### 关系运算符

**`>、<、>=、<=、==、!=`**

`=`为赋值符号，使用`==`检测是否相等，而`!=`检测是否不相等

> Java中检测两个变量是否相等时，会检测变量的引用
>
> 基本类型引用的是字面量，可直接比较
>
> 而引用对象时，引用的是对象在内存中存储的地址，即便同一个类的两个不同对象的属性完全相同，也会返回`false`，所以比较对象时一般使用重载的`equals`方法==



### 逻辑运算符

**`&&、||、!`**

- **&&（逻辑与）**

  `expression1 && expression2`

  两边都为`true`则返回`true`否则返回`false`

- **||（逻辑或）**

  `expression1 || expression2`

  两边都为`false`则返回`false`否则返回`true`

- **!（逻辑非）**

  `!expression`

  反转表达式结果，`true`变为`false`，`false`变为`true`

> **短路：**
>
> 如果第一个操作数已经能够确定表达式的值，第二个操作数就不会去计算了
>
> 如果不想使用短路，可使用位运算符`&`或`|`



### 条件运算符

**`?!`**

使用方法：`condition ? expression1 ! expression2`

==若condition结果为`true`返回表达式1的值，否则返回表达式2的值==



## 位运算符

`&(and)、|(or)、^(xor)、~(not)、>>、<<、>>>`

==使两个操作数按位模式处理==

- `<<`将位模式左移
- `>>`和`>>>`将位模式右移
  - `>>`使用被操作数的符号位填充高位
  - `>>>`只会使用`0`填充高位

> 移位运算的右操作数需要进行模32的运算（左操作数位`long`类型时进行模64的运算）
>
> `1 << 35 == 1 << 3 == 1 << 8`



## 赋值运算符

- **简单赋值运算符**：**`=`**

- **扩展赋值运算符**：**`+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=、>>>=`**   

  ==扩展赋值运算符自带强转功能==

  ```java
  int a = 5;
  a += 10; // a=(int)(a+10) // 15
  a *= 2; // a=(int)(a*2) // 30
  a /= 6; // a=(int)(a/6) // 5
  ```



# 流程控制

> 程序代码结构分为三种：
>
> - **顺序结构**（从上往下逐行执行）
> - **分支结构**（有条件地执行某段代码）
> - **循环结构**（有条件地重复执行某段代码）



## 分支结构

### if语句

==限定一条语句或语句块在某个条件为真时才能执行==



`if (conditon) statement`

**条件为真时才会执行语句，否则跳过该语句**



`if (condition) statement1`

`else statement2`

**条件为真执行语句1，否则执行语句2（必走一条）**



==`else`只会与邻近的`if`构成一组==

```java
if (x <= 0) if (x == 0) ...; else ...;
// else会与第二个if配对，这种情况情况需要添加大括号，使代码更清晰
if (x <= 0) {if (x == 0) ...; else ...;}
```



**可以使用`else`接`if`的方式无限扩展分支结构**

```java
if (condition1) statement1;
else if (condition2) statement2;
else if (condition3) statement3;
...
else statementN;
```



### switch语句

==提供一个变量，与分支上的变量相等时执行该分支中的语句或语句块==



```Java
switch (var)
{
    case var1:
        [statement]
        [break;]
    case var2:
        [statement]
        [break;]
    case var3:
        [statement]
        [break;]
    default:
        [statement]
        [break;]
}
```



**switch分支用于判断的变量只支持以下几种类型：**

- **char、byte、short、int**
- **JDK5.0之后，支持枚举类型**
- **JDK7.0之后，支持String字符串**



#### default分支

**`default`分支是可选的，如果没有匹配成功的分支，程序会去寻找default，如果没有则结束switch语句**

> 如果发生贯穿，default会以正常顺序参与其中（不会强制在末尾执行）



#### 贯穿

==如果匹配到了一条分支，程序会从该分支开始往后执行每一条分支，直至遇到`break`关键字==

> 如果default分支在第一个，且没有匹配成功的分支
>
> 意味着switch会从头开始贯穿



## 循环结构

### while循环

==条件为真时反复执行一条语句或语句块（先判断后执行）==

`while (condition) statement`

```Java
int i = 0;
while (i < 10)
{
    // ...
    i++;
}
// i小于10时反复执行语句块，每执行一次i的值加一，将会执行十次
```



### do...while循环

==条件为真时反复执行一条语句或语句块（先执行后判断）==

`do statement while (condition);`



### for循环

==while循环的变体，将计数器（用于控制条件的变量）的声明、条件语句、计数器变化语句放在一起==

`for (expression1;expression2;expression3) statement`

- **语句1：计数器初始化语句**
- **语句2：条件语句**
- **语句3：计数器变化语句**

==**执行顺序：语句1>语句2>循环体>语句3**==

> 这三个语句都是可选的，但是分号必须存在，且不能改变位置
>
> `for (;;) ...`这条语句等同于`while (true) ...`

==写在小括号中的语句1中定义的变量，其作用域为for循环的循环体内==



### for each循环

`for (variable : collection) statement`

==专为数组与集合准备的循环语句，用于遍历每一个元素（被遍历的对象必须为数组或实现了Iterable接口的对象）==

```Java
int a = [1, 2, 3, 4, 5];
for (int i: a) ...; // 定义一个变量存储数组或集合的每一个元素
```

> 编译器会将遍历数组的foreach语句编译为带计数器的普通for循环，将遍历集合的foreach语句编译为迭代器遍历
>
> ```Java
> // 编译前
> int[] a = {1,2,3,4,5};
> for (int i: a)
>  System.out.println(i);
> // 编译后
> int[] a = new int[]{1, 2, 3, 4, 5};
> int[] var2 = a;
> int var3 = a.length;
> for(int var4 = 0; var4 < var3; ++var4) {
>  int i = var2[var4];
>  System.out.println(i);
> }
> 
> // 编译前
> List<Integer> list = new ArrayList<>();
> list.add(1);
> list.add(2);
> list.add(3);
> for (Integer i: list)
>  System.out.println(i);
> // 编译后
> List<Integer> list = new ArrayList();
> list.add(1);
> list.add(2);
> list.add(3);
> Iterator var2 = list.iterator();
> while(var2.hasNext()) {
>  Integer i = (Integer)var2.next();
>  System.out.println(i);
> }
> ```



## break、continue与标签

==`break`与`continue`用于中断循环==

- **break**

  跳转到循环语句之后

- **continue**

  - while循环与do...while循环会跳转到下一次条件判断之前
  - for循环会跳转到编写在小括号中的计数器变化语句之前

> 可以理解为快进到一个位置，过程中的语句不执行0



==**标签：**自定义的标识符，可以标记在语句块、分支语句、循环语句上==

语法：`label: loop`

`break/continue label;`



- `break`会跳转到被标记语句之后（立刻结束被标记语句）

- `continue`的目标**只能是循环语句**，效果与无标签语句相同（目标循环执行一次continue操作）

> 标签跳转只能在多重嵌套循环中使用，且只能从内部循环向外跳转，不能向内跳入内层循环

```Java
// 打印乘法表
outside:
for (int i = 1; i <= 9; i++)
{
    temp:
    if (i != 1) System.out.println(); // 用于输出转行
    
    for (int j = 1; j <= i; j++)
    {
        if (j == 3) continue outside; // j等于3时跳转到外部循环的下一次循环
        // if (j == 6) break temp; // 编译错误，跳转目标必须是包裹了当前语句的外部语句
        if (i == 6) break outside; // i等于6时跳转到外部循环结束
        
        System.out.printf("%d * %d = %d\t", i, j, i * j);
    }
}

/*
    输出效果：
    1 * 1 = 1
    1 * 2 = 2	2 * 2 = 4
    1 * 3 = 3	2 * 3 = 6
    1 * 4 = 4	2 * 4 = 8
    1 * 5 = 5	2 * 5 = 10
*/
```



# 输入与输出

## 控制台输入与输出

### 读取输入

==从控制台输入时，需要创建`Scanner`对象，并传入**标准输入流`System.in`**作为参数==

`Scanner in = new Scanner(System.in);`

**常用方法：**

- `nextLine`读取一行
- `next`读取一个单词
- `nextInt`读取一个整数
- `nextDouble`读取一个浮点数

> 使用空白符作为分隔符（`nextLine`只能使用换行符）



### 格式化输出

`System.out.printf(String format, Object... o);`

第一个参数为表示需要输出的格式的字符串，第二个参数为类型为`Object`的可变参数，用于替换格式中指定的部分

> 例如：
>
> ```Java
> double x = 10000.0 / 3.0;
> System.out.printf("%8.2f", x);
> // 以最少8个字符的宽度、小数点后两个字符的精度打印x，将在控制台打印：" 3333.33"（前面有一个空格，加上后面的3333.33供8个字符）
> ```



==以`%`字符开始的格式说明符都会被相应的参数替换，格式说明符尾部的转换符表示被格式化的数值类型==



**转换符：**

| 转换符 |      类型      |    举例    | 转换符 |              类型               |  举例   |
| :----: | :------------: | :--------: | :----: | :-----------------------------: | :-----: |
|   d    |   十进制整数   |    159     |   s    |             字符串              |  Hello  |
|   x    |   十六进制数   |     9f     |   c    |              字符               |    H    |
|   o    |    八进制数    |    237     |   b    |              布尔               |  true   |
|   f    |   定点浮点数   |    15.9    |   h    |             散列码              | 42628b2 |
|   e    |   指数浮点数   |  1.59c+01  | tx/Tx  | 日期时间（T强制大写）（已过时） |   --    |
|   g    |   通用浮点数   |     --     |   %    |             百分号              |    %    |
|   a    | 十六进制浮点数 | 0x1.fccdp3 |   n    |      与平台有关的行分隔符       |   --    |

> s转换符可以格式化任意对象
>
> 实现了`Formattable`接口的对象会被调用`formatTo`方法，否则会被调用`toString`方法



**可以在格式说明符中添加一些标志用于控制格式化输出**

```java
`System.out.printf("%,.2f", 10000.0 / 3.0);`
// 打印："3,333.33"
```

> 可以使用多个标志
>
> 例如：`%,(.2f`表示使用分组的分隔符并将负数括在括号内



**控制标志：**

|         标志          |                             目的                             |                  举例                  |
| :-------------------: | :----------------------------------------------------------: | :------------------------------------: |
|           +           |                     打印整数和负数的符号                     |                +3333.33                |
|         空格          |                      在整数之前添加空格                      |               " 3333.33"               |
|           0           |                         数字前面补零                         |                03333.33                |
|           -           |                            左对齐                            | "3333.33 "（顶到了左边，空格到了末尾） |
|           (           |                       将负数括在括号内                       |               (3333.33)                |
|           ,           |                        添加分组分隔符                        |                3,333.33                |
|   #（对于`f`格式）    |                  小数精度为0时也打印小数点                   |        `("%#.0f", 4.0 / 2)`：2.        |
| #（对于`x`或`o`格式） |                      添加前缀`0x`或`0`                       |                 0xcafe                 |
|           $           | 给定被格式化的参数索引。例如，`%1$d`，以十进制打印第一个参数 |         `("%2$d", 10, 20)`：20         |
|           <           | 格式化上一个格式说明符指向的数值。例如`%d%<x`，以十进制和十六进制打印同一个数值 |         `("%d%<x", 20)`：2014          |

> String类的`format`静态方法能够以同样的方式创建一个字符串
>
> `String format(String format, Object... o)`



### 格式化日期

> **这种方法已经过时**
>
> **现在通常使用`java.time`包下的方法**

`Date`类拥有特殊的格式化选项

它的转换符包含一个转换符`t`和一个日期转换符

> 例如：
>
> `System.out.printf("%tc", new Date())`
>
> 这个语句将以默认格式打印当前的日期和时间：
>
> `Mon Feb 09 18:05:19 PST 2015`



**日期转换符：**

| 转换符       | 类型                                          | 举例                         |
| ------------ | --------------------------------------------- | ---------------------------- |
| c            | 完整的日期和时间                              | Mon Feb 09 18:05:19 PST 2015 |
| F            | ISO 8601日期                                  | 2015-02-09                   |
| D            | 美国格式的日期（月/日/年）                    | 02/09/2015                   |
| T            | 24小时时间                                    | 18:05:19                     |
| r            | 12小时时间                                    | 06:05:19pm                   |
| R            | 24小时时间（没有秒）                          | 18:05                        |
| Y            | 4位数字的年（自动补0）                        | 2015                         |
| y            | 年的后两位数字（自动补0）                     | 15                           |
| C            | 年的前两位数字（自动补0）                     | 20                           |
| B            | 月的完整拼写                                  | February                     |
| b/h          | 月的缩写                                      | Feb                          |
| m            | 两位数字的月（自动补0）                       | 02                           |
| d            | 两位数字的日（自动补0）                       | 09                           |
| e            | 两位数字的日（不补0）                         | 9                            |
| A            | 星期的完整拼写                                | Monday                       |
| a            | 星期的缩写                                    | Mon                          |
| j            | 三位数字的当前年已过天数（自动补0，001~366）  | 069                          |
| H            | 两位数字的小时（自动补0，0~23）               | 18                           |
| k            | 两位数字的小时（不补0，0~23）                 | 18                           |
| I（大写`I`） | 两位数字的小时（自动补0，0~12）               | 06                           |
| l（小写`L`） | 两位数字的小时（不补0，0~12）                 | 6                            |
| M            | 两位数字的分钟（自动补0）                     | 05                           |
| S            | 两位数字的秒（自动补0）                       | 19                           |
| L            | 三位数字的毫秒（自动补0）                     | 047                          |
| N            | 九位数字的纳秒（自动补0）                     | 047000000                    |
| p            | 上午或下午的标志                              | pm                           |
| z            | 从GMT起，RFC822数字位移（数字表示的时区）     | -0800（中国为+0800）         |
| Z            | 时区                                          | PST（中国为CST               |
| s            | 从格林威治时间`1970-01-01 00:00:00`起的秒数   | 1078884319                   |
| Q            | 从格林威治时间`1970-01-01 00:00:00`起的毫秒数 | 1078884319047                |



## 文件输入与输出

### 读取文件

**使用一个`File`对象构造一个`Scanner`对象**

`Scanner in = new Scanner(Paths.get("文件路径"), "UTF-8");`

参数不可以是字符串对象，若传入字符串，得到的`Scanner`对象只会从字符串中的读取数据

如果文件不存在，会抛出异常

> 若不指定字符集，会默认使用运行程序的机器的默认编码



### 写入文件

`PrintWriter out = new PrintWriter("文件路径", "UTF-8");`

可以和`System.out`一样使用`print、println、printf`等方法

如果文件不存在，会创建该文件



# 继承

==继承的明显特征为"is-a"关系==

> 例如："cat is an animal"，Cat类就继承自Animal类，拥有Animal共有的属性和行为



使用**关键字`extends`**表示正在构造的新类继承或派生自一个已存在的类

已存在的类称为超类（superclass）、基类（base class）或父类（parent class），新类称为子类（subclass）、派生类（derived class）或孩子类（child class）

==超类并不表示比子类拥有更多的功能，相反，子类往往比超类封装了更多的数据和功能==

> 前缀“超”和“子”来源于计算机科学和数学理论中的集合语言的术语
>
> 所有动物组成的集合包含所有猫组成的集合，也就是说，动物集合是猫集合的超集，猫集合是动物集合的子集

```java
class Animal
{
    String name;
    String getName() {return name;}
}

// Cat类继承Animal类
class Cat extends Animal
{
    // Cat类不需要定义name属性和getName方法
    // 由于Cat类继承了Animal类，Cat类的对象可以直接使用name属性和getName方法
    name = "kitty";
    void print() {System.out.println(getName());}
}
```



**继承层次：**

==由一个公共超类派生出来的所有类的集合被称为继承层次==

```
Animal
	- Cat
	- Dog
		- teddy
```

从某一个特定的类到其祖先的路径被称为**该类的继承链**



## 方法继承与覆盖

==子类可以直接调用超类的**公开或受保护方法**，也可以声明相同的方法覆盖该方法==



### super

==`super`是一个指示编译器调用超类属性或方法的特殊关键字，它不是一个对象的引用，要与`this`区分开==

```Java
class Parent
{
    void method()
    {
        // ...
    }
}

class Child extends Parent
{
    @Override
    void method()
    {
        // 重写超类方法
        super.method(); // 调用超类中的方法实现
    }
}
```



### 构造器

==在子类构造器的第一句可以使用类似`this(...)`的方式调用`super(...)`，表示调用超类构造器==

> `super(...)`只能在第一句出现，`this(...)`和`super(...)`不能一起使用

**如果子类没有显式地调用超类构造器，则默认调用超类的无参构造器；如果超类没有无参构造器，且子类构造器中没有显式地调用超类的有参构造器，编译器会报错**



## 多态

==每个子类的对象也是超类的对象，可以将子类的引用赋值给超类变量，但是不能将一个超类的引用赋值给子类变量==

> 引用类型为超类时调用方法，调用的就是超类的方法，引用类型为子类时调用方法，如果子类重写了该方法，调用的就是子类的方法

```java
class Animal
{
    String getName() {return "动物";}
}

class Cat extends Animal
{
    @Override
    String getName() {return "猫";}
}

class Test
{
    public static void main(String[] args)
    {
        Animal animal = new Cat();
        String name = animal.getName(); // 猫
    }
}
```

> 虚拟机知道对象变量实际的引用类型，能够正确的调用相应的方法



==一个变量可以指示多种实际类型的现象称为**多态**，最大的特征为**动态绑定**==



## 阻止继承：final类和方法

==不允许扩展的类称为**final类**==，在定义类时使用`final`修饰符表示这个类是final类

```Java
// 任何类都不可以继承这个类
public final class OOP
{
    // ...
}
```



如果在定义方法时使用`final`修饰符，那么子类就不能覆盖这个方法（final类中的所有方法默认被`final`修饰，属性不会）

```java
class Parent
{
    private String name;
    public final String getName() {return name;}
}

class Child extends Parent
{
    // public String getName() {return name;}
    // 编译错误，被final修饰的方法不能被重写
}
```



## 强制类型转换
